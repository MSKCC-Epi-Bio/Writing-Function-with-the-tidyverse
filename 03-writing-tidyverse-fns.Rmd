---
output: html_document
editor_options: 
  chunk_output_type: console
---
class: inverse, center, middle
# Writing tidyverse-style Functions

---

# Two Options for Writing tidyverse-style Functions

* Option 1: Write a function that uses **quoted** arguments in the function call

```{r, eval = FALSE}
# calling tbl_summary using quoted arguments
tbl_summary(trial, include = c("trt", "age"))
```

* Option 2: Write a function that uses **unquoted** arguments in the function call 
(also known as *bare arguments*)

```{r, eval = FALSE}
# calling tbl_summary using unquoted arguments (not all functions accept quoted + unquoted input)
tbl_summary(trial, include = c(trt, age))
```

* Requiring quoted or unquoted function arguments is a matter of developer 
preference

* May be slightly easier for the user to supply unquoted arguments (less typing)

* The type of argument required by the function (quoted or unquoted)
should be specified in the help file when writing functions more formally

* `tbl_summary()` is unique in that it takes both quoted and unquoted 
arguments. This is more work for the developer and isn't necessarily recommended.

---

# Tidy evaluation

**Tidy evaluation:** A framework for controlling how expressions and variables
in your code are evaluated by tidyverse functions.

* Useful for passing variable names as inputs to functions
that use tidyverse packages like `dplyr` and `ggplot2`

---

class: inverse, center, middle
# Option 1: Writing functions that use quoted arguments in a function call

---

# Passing Strings to dplyr verbs

* This means that you want to use any of the `dplyr` verbs in your function,
and want to pass a string (i.e., the user is supplying a quoted argument)

`dplyr` verbs: 

* `select()`: picks variables based on their names

* `group_by()`: converts an existing table to a grouped table, where operations
are performed by group

* `filter()`: picks cases based on their values

* `mutate()`: adds new variables based on existing variables

---

# Passing Strings to select() 

A first attempt:

```{r, eval = FALSE}
# using a function to select a single variable
my_select_function <- function(select_variable){
  gtsummary::trial %>% 
    dplyr::select(select_variable)
}

my_select_function(select_variable = "trt")
# this works, but we get a note
# Note: Using an external vector in selections is ambiguous.
# i Use `all_of(select_variable)` instead of `select_variable` to silence this message.
# i See <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.
```

Why did we get this note? *Within the function, it's not clear if the* 
*select variable is a .data or an .env variable*

---

# Passing Strings to select()

One solution is to clarify that we are indicating that the variable to 
select is a `.data` variable

We can do that by using `.data[[ Â· ]]` (`.data` $\ne$ data frame, but is a 
way of telling R to look for a data variable)

```{r, eval=FALSE}
my_select_function <- function(select_variable){
  gtsummary::trial %>% 
    dplyr::select(.data[[select_variable]])
}

my_select_function(select_variable = "trt")
# A tibble: 200 x 1
#   trt   
#   <chr> 
# 1 Drug A
# 2 Drug B
# etc.
```

---

# Functions for Passing Strings to select()

* If we want to select multiple variables, can utilize the following functions

* `any_of()` and `all_of()` are helper functions to select variables from 
a character vector

* `any_of()`: selecting any of the listed variables

* `all_of()`: for strict selection. If any of the variables in the character vector is missing, an error is thrown

* Can also use `!all_of()` to select all variables not found in the character vector supplied to `all_of()`

```{r, eval = FALSE}
# using a function to select multiple variables
my_select_function <- function(select_variable){
  gtsummary::trial %>% 
    dplyr::select(dplyr::all_of(select_variable))
}

my_select_function(select_variable = c("trt", "age"))
# A tibble: 200 x 2
#   trt      age
#   <chr>  <dbl>
# 1 Drug A    23
# 2 Drug B     9
# etc.
```

---

# Passing Strings to group_by()

A first attempt:

```{r, eval=FALSE}
my_group_function <- function(group_vars){
  gtsummary::trial %>% 
    dplyr::group_by(group_vars) %>% 
    dplyr::summarize(n = n())
}

my_group_function(group_vars = "trt")
#  Error: Must group by variables found in `.data`.
# * Column `group_vars` is not found.
```

---

# Passing Strings to group_by()

* Passing a single variable to group by

```{r, eval=FALSE}
my_group_function <- function(group_var){
  gtsummary::trial %>% 
    dplyr::group_by(.data[[group_var]])
}

my_group_function(group_var = "trt")
# A tibble: 200 x 8
# Groups:   trt [2]
#   trt      age marker stage grade response death ttdeath
#   <chr>  <dbl>  <dbl> <fct> <fct>    <int> <int>   <dbl>
# 1 Drug A    23  0.16  T1    II           0     0    24  
# 2 Drug B     9  1.11  T2    I            1     0    24 
```
---

# Passing Strings to group_by()

* Passing multiple variables to group by 

* `across()`: allows you to use `select()` semantics inside in data-masking
functions

```{r, eval=FALSE}
my_group_function <- function(group_vars){
  gtsummary::trial %>% 
    dplyr::group_by(across(group_vars))
}

my_group_function(group_vars = c("trt", "stage"))
# A tibble: 200 x 8
# Groups:   trt, stage [8]
#   trt      age marker stage grade response death ttdeath
#   <chr>  <dbl>  <dbl> <fct> <fct>    <int> <int>   <dbl>
# 1 Drug A    23  0.16  T1    II           0     0    24  
# 2 Drug B     9  1.11  T2    I            1     0    24  
```
---

# Passing Strings to filter()

A first attempt:

```{r, eval = FALSE}
# using a function to select a single variable
my_filter_function <- function(filter_condition){
  gtsummary::trial %>% 
    dplyr::filter(filter_condition)
}

my_filter_function(filter_condition = "age > 65")
# Error: Problem with `filter()` input `..1`.
# i Input `..1` is `filter_condition`.
# x Input `..1` must be a logical vector, not a character.
```

Why did we get this note? *The character condition needs to be an expression*

---

# Functions for Passing Strings to filter()

* `parse()`: transforms text into an un-evaluated expression 
(i.e., it removes the quotation marks)

* `eval()`: Evaluates the expression

* Can alternatively use `!!` injector & `rlang::parse_expr()`


```{r, eval = FALSE}
my_filter_function <- function(filter_condition){
  gtsummary::trial %>% 
    dplyr::filter(!!rlang::parse_expr(filter_condition))
}

my_filter_function(filter_condition = "age > 65")

# A tibble: 23 x 8
#   trt      age marker stage grade response death ttdeath
#   <chr>  <dbl>  <dbl> <fct> <fct>    <int> <int>   <dbl>
# 1 Drug B    71  0.445 T4    III          0     1    8.71
# 2 Drug B    67  1.16  T1    II           0     0   24   
# 3 Drug B    68  0.105 T4    II           0     1   15.4 
# etc.
```

---

# Functions for Passing Strings to mutate()

A first attempt: 

```{r, eval=FALSE}
my_mutate_function <- function(mutate_var){
  gtsummary::trial %>% 
    dplyr::mutate(mean = mean(mutate_var, na.rm = TRUE))
}

my_mutate_function(mutate_var = "age")
# mean column entirely missing
# A tibble: 200 x 9
#   trt      age marker stage grade response death ttdeath  mean
#   <chr>  <dbl>  <dbl> <fct> <fct>    <int> <int>   <dbl> <dbl>
# 1 Drug A    23  0.16  T1    II           0     0    24      NA
# 2 Drug B     9  1.11  T2    I            1     0    24      NA
# 3 Drug A    31  0.277 T1    II           0     0    24      NA
# etc.

# Warning message:
# Problem with `mutate()` column `mean`.
# i `mean = mean(mutate_var, na.rm = TRUE)`.
```

---

# Functions for Passing Strings to mutate()

```{r, eval=FALSE}
my_mutate_function <- function(mutate_var){
  gtsummary::trial %>% 
    dplyr::mutate(mean = mean(.data[[mutate_var]], na.rm = TRUE))
}

my_mutate_function(mutate_var = "age")

# A tibble: 200 x 9
#   trt      age marker stage grade response death ttdeath  mean
#   <chr>  <dbl>  <dbl> <fct> <fct>    <int> <int>   <dbl> <dbl>
# 1 Drug A    23  0.16  T1    II           0     0    24    47.2
# 2 Drug B     9  1.11  T2    I            1     0    24    47.2
```

---

# Naming new variables created within your function

* Cue, the walrus operator `:=`

* Part of the `rlang` package

* `{glue}` syntax is automatically recognized on the left-hand side of the  
walrus operator

```{r, eval=FALSE}
my_naming_function <- function(variable){
  gtsummary::trial %>% 
    dplyr::mutate("mean_{variable}" := mean(.data[[variable]], na.rm = TRUE))
}

my_naming_function(variable = "age")
# A tibble: 200 x 9
#  trt      age marker stage grade response death ttdeath mean_age
#  <chr>  <dbl>  <dbl> <fct> <fct>    <int> <int>   <dbl>    <dbl>
# 1 Drug A    23  0.16  T1    II           0     0    24       47.2
# 2 Drug B     9  1.11  T2    I            1     0    24       47.2
```

---

class: inverse, center, middle

# Questions?